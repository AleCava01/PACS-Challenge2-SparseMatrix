\doxysection{Matrix.\+tpp}
\hypertarget{_matrix_8tpp_source}{}\label{_matrix_8tpp_source}\index{include/Matrix.tpp@{include/Matrix.tpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ /*\ This\ .tpp\ file\ contains\ the\ implementation\ of\ the\ Matrix\ class\ template.\ }
\DoxyCodeLine{00002\ It\ defines\ methods\ for\ matrix\ operations,\ including\ sparse\ matrix\ compression,\ matrix-\/vector\ multiplication,\ and\ I/O\ operations.\ }
\DoxyCodeLine{00003\ The\ implementation\ supports\ both\ uncompressed\ (COO)\ and\ compressed\ (CSR/CSC)\ formats,\ optimizing\ memory\ usage\ and\ performance\ for\ large\ datasets.}
\DoxyCodeLine{00004\ \ */}
\DoxyCodeLine{00005\ \#include\ "{}Matrix.hpp"{}}
\DoxyCodeLine{00006\ }
\DoxyCodeLine{00007\ namespace\ algebra\{}
\DoxyCodeLine{00008\ }
\DoxyCodeLine{00009\ //\ üèóÔ∏è\ CONSTRUCTORS}
\DoxyCodeLine{00010\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00011\ Matrix<T,\ Order>::Matrix(size\_t\ rows,\ size\_t\ cols)\{}
\DoxyCodeLine{00012\ \ \ \ \ rows\_\ =\ rows;}
\DoxyCodeLine{00013\ \ \ \ \ cols\_\ =\ cols;}
\DoxyCodeLine{00014\ \}}
\DoxyCodeLine{00015\ }
\DoxyCodeLine{00016\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00017\ Matrix<T,\ Order>::Matrix(const\ std::vector<std::vector<T>>\&\ mat)\ \{}
\DoxyCodeLine{00018\ //\ Constructor\ from\ a\ 2D\ vector.}
\DoxyCodeLine{00019\ //\ Initializes\ the\ matrix\ dimensions\ and\ populates\ sparse\_data\_\ using\ the\ update()\ method.}
\DoxyCodeLine{00020\ }
\DoxyCodeLine{00021\ \ \ \ \ if\ (mat.empty()\ ||\ mat[0].empty())\ \{}
\DoxyCodeLine{00022\ \ \ \ \ \ \ \ \ rows\_\ =\ 0;}
\DoxyCodeLine{00023\ \ \ \ \ \ \ \ \ cols\_\ =\ 0;}
\DoxyCodeLine{00024\ \ \ \ \ \}\ else\ \{}
\DoxyCodeLine{00025\ \ \ \ \ \ \ \ \ rows\_\ =\ mat.size();}
\DoxyCodeLine{00026\ \ \ \ \ \ \ \ \ cols\_\ =\ mat[0].size();}
\DoxyCodeLine{00027\ \ \ \ \ \ \ \ \ for\ (size\_t\ i\ =\ 0;\ i\ <\ mat.size();\ ++i)\ \{}
\DoxyCodeLine{00028\ \ \ \ \ \ \ \ \ \ \ \ \ for\ (size\_t\ j\ =\ 0;\ j\ <\ mat[i].size();\ ++j)\ \{}
\DoxyCodeLine{00029\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ update(i,\ j,\ mat[i][j]);}
\DoxyCodeLine{00030\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00031\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00032\ \ \ \ \ \}}
\DoxyCodeLine{00033\ \}}
\DoxyCodeLine{00034\ }
\DoxyCodeLine{00035\ //\ üî•\ CORE\ METHODS}
\DoxyCodeLine{00036\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00037\ bool\ Matrix<T,\ Order>::update(const\ size\_t\ i,\ const\ size\_t\ j,\ const\ T\&\ value)\ \{}
\DoxyCodeLine{00038\ //\ Updates\ the\ value\ at\ position\ (i,\ j)\ in\ the\ uncompressed\ (sparse\_data\_)\ format.}
\DoxyCodeLine{00039\ //\ Inserts\ or\ updates\ the\ value\ if\ it's\ non-\/zero;\ removes\ the\ entry\ if\ the\ value\ is\ zero.}
\DoxyCodeLine{00040\ \ }
\DoxyCodeLine{00041\ \ \ \ \ std::array<size\_t,\ 2>\ key\ =\ \{i,\ j\};}
\DoxyCodeLine{00042\ \ \ \ \ if\ (value\ !=\ T(0))\ \{}
\DoxyCodeLine{00043\ \ \ \ \ \ \ \ \ sparse\_data\_[key]\ =\ value;}
\DoxyCodeLine{00044\ \ \ \ \ \}\ else\ \{}
\DoxyCodeLine{00045\ \ \ \ \ \ \ \ \ sparse\_data\_.erase(key);}
\DoxyCodeLine{00046\ \ \ \ \ \}}
\DoxyCodeLine{00047\ \ \ \ \ return\ true;}
\DoxyCodeLine{00048\ \}}
\DoxyCodeLine{00049\ }
\DoxyCodeLine{00050\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00051\ void\ Matrix<T,\ Order>::compress()\ \{}
\DoxyCodeLine{00052\ //\ Converts\ the\ matrix\ from\ uncompressed\ (Coo-\/MAP)\ format\ to\ compressed\ format\ (CSR\ for\ RowMajor,\ CSC\ for\ ColMajor).}
\DoxyCodeLine{00053\ //\ It\ builds\ compressed\_data\_\ from\ sparse\_data\_\ and\ then\ clears\ the\ uncompressed\ storage\ to\ save\ memory.}
\DoxyCodeLine{00054\ }
\DoxyCodeLine{00055\ \ \ \ \ //\ Determine\ the\ conversion\ type}
\DoxyCodeLine{00056\ \ \ \ \ constexpr\ bool\ isRowMajor\ =\ (Order\ ==\ StorageOrder::RowMajor);}
\DoxyCodeLine{00057\ \ \ \ \ size\_t\ outer\_size\ =\ isRowMajor\ ?\ rows\_\ :\ cols\_;}
\DoxyCodeLine{00058\ }
\DoxyCodeLine{00059\ \ \ \ \ //\ Clears\ the\ values\ and\ preparation}
\DoxyCodeLine{00060\ \ \ \ \ compressed\_data\_.values.clear();}
\DoxyCodeLine{00061\ \ \ \ \ compressed\_data\_.inner\_index.clear();}
\DoxyCodeLine{00062\ \ \ \ \ compressed\_data\_.outer\_ptr.assign(outer\_size\ +\ 1,\ 0);\ \ //\ initialise\ outer\_ptr\ with\ zeroes}
\DoxyCodeLine{00063\ }
\DoxyCodeLine{00064\ \ \ \ \ //\ 1.\ Counts\ the\ values\ in\ each\ row/column}
\DoxyCodeLine{00065\ \ \ \ \ for\ (const\ auto\&\ [key,\ val]\ :\ sparse\_data\_)\ \{}
\DoxyCodeLine{00066\ \ \ \ \ \ \ \ \ size\_t\ outer\ =\ isRowMajor\ ?\ key[0]\ :\ key[1];\ \ //\ if\ CSR\ uses\ the\ row\ as\ outer\ if\ CSC\ uses\ the\ column\ \ }
\DoxyCodeLine{00067\ \ \ \ \ \ \ \ \ compressed\_data\_.outer\_ptr[outer\ +\ 1]++;\ \ \ //\ to\ know\ how\ many\ elements\ are\ in\ each\ column/row}
\DoxyCodeLine{00068\ \ \ \ \ \}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{00069\ }
\DoxyCodeLine{00070\ \ \ \ \ //\ 2.\ Indicates\ where\ starts\ each\ row}
\DoxyCodeLine{00071\ \ \ \ \ for\ (size\_t\ i\ =\ 1;\ i\ <=\ outer\_size;\ ++i)\ \{\ \ //\ outer\_ptr[i]\ \ \ -\/>\ index\ of\ starting\ of\ the\ i-\/th\ row/column\ in\ the\ vector\ values\ \ }
\DoxyCodeLine{00072\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ //\ outer\_ptr[i+1]\ -\/>\ index\ excluded\ of\ the\ next\ row}
\DoxyCodeLine{00073\ \ \ \ \ \ \ \ \ compressed\_data\_.outer\_ptr[i]\ +=\ compressed\_data\_.outer\_ptr[i\ -\/\ 1];}
\DoxyCodeLine{00074\ \ \ \ \ \}}
\DoxyCodeLine{00075\ }
\DoxyCodeLine{00076\ \ \ \ \ //\ 3.\ Allocates\ space\ and\ to\ not\ call\ pushback\ each\ time\ }
\DoxyCodeLine{00077\ \ \ \ \ size\_t\ nnz\ =\ sparse\_data\_.size();\ \ //\ total\ number\ of\ non\ zero\ values\ }
\DoxyCodeLine{00078\ \ \ \ \ compressed\_data\_.values.resize(nnz);}
\DoxyCodeLine{00079\ \ \ \ \ compressed\_data\_.inner\_index.resize(nnz);}
\DoxyCodeLine{00080\ \ \ \ \ std::vector<size\_t>\ temp\_offset\ =\ compressed\_data\_.outer\_ptr;}
\DoxyCodeLine{00081\ }
\DoxyCodeLine{00082\ \ \ \ \ //\ 4.\ Giving\ values\ to\ the\ vectors}
\DoxyCodeLine{00083\ \ \ \ \ for\ (const\ auto\&\ [key,\ val]\ :\ sparse\_data\_)\ \{}
\DoxyCodeLine{00084\ \ \ \ \ \ \ \ \ size\_t\ outer\ =\ isRowMajor\ ?\ key[0]\ :\ key[1];}
\DoxyCodeLine{00085\ \ \ \ \ \ \ \ \ size\_t\ inner\ =\ isRowMajor\ ?\ key[1]\ :\ key[0];}
\DoxyCodeLine{00086\ \ \ \ \ \ \ \ \ size\_t\ idx\ =\ temp\_offset[outer]++;}
\DoxyCodeLine{00087\ }
\DoxyCodeLine{00088\ \ \ \ \ \ \ \ \ compressed\_data\_.values[idx]\ =\ val;}
\DoxyCodeLine{00089\ \ \ \ \ \ \ \ \ compressed\_data\_.inner\_index[idx]\ =\ inner;}
\DoxyCodeLine{00090\ \ \ \ \ \}}
\DoxyCodeLine{00091\ }
\DoxyCodeLine{00092\ \ \ \ \ sparse\_data\_.clear();}
\DoxyCodeLine{00093\ }
\DoxyCodeLine{00094\ \}}
\DoxyCodeLine{00095\ }
\DoxyCodeLine{00096\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00097\ void\ Matrix<T,\ Order>::decompress()\ \{}
\DoxyCodeLine{00098\ //\ Converts\ the\ matrix\ from\ compressed\ form\ (CSR/CSC)\ to\ uncompressed\ form\ (Coo-\/MAP).}
\DoxyCodeLine{00099\ //\ It\ reconstructs\ sparse\_data\_\ using\ the\ compressed\_data\_\ arrays\ and\ clears\ the\ compressed\ storage\ afterward.}
\DoxyCodeLine{00100\ }
\DoxyCodeLine{00101\ \ \ \ \ sparse\_data\_.clear();}
\DoxyCodeLine{00102\ }
\DoxyCodeLine{00103\ \ \ \ \ constexpr\ bool\ isRowMajor\ =\ (Order\ ==\ StorageOrder::RowMajor);}
\DoxyCodeLine{00104\ \ \ \ \ size\_t\ outer\_size\ =\ compressed\_data\_.outer\_ptr.size()\ -\/\ 1;}
\DoxyCodeLine{00105\ }
\DoxyCodeLine{00106\ \ \ \ \ for\ (size\_t\ outer\ =\ 0;\ outer\ <\ outer\_size;\ ++outer)\ \{}
\DoxyCodeLine{00107\ \ \ \ \ \ \ \ \ for\ (size\_t\ k\ =\ compressed\_data\_.outer\_ptr[outer];\ k\ <\ compressed\_data\_.outer\_ptr[outer\ +\ 1];\ ++k)\ \{}
\DoxyCodeLine{00108\ \ \ \ \ \ \ \ \ \ \ \ \ size\_t\ inner\ =\ compressed\_data\_.inner\_index[k];}
\DoxyCodeLine{00109\ }
\DoxyCodeLine{00110\ \ \ \ \ \ \ \ \ \ \ \ \ size\_t\ i\ =\ isRowMajor\ ?\ outer\ :\ inner;}
\DoxyCodeLine{00111\ \ \ \ \ \ \ \ \ \ \ \ \ size\_t\ j\ =\ isRowMajor\ ?\ inner\ :\ outer;}
\DoxyCodeLine{00112\ }
\DoxyCodeLine{00113\ \ \ \ \ \ \ \ \ \ \ \ \ update(i,\ j,\ compressed\_data\_.values[k]);\ \ //\ utilizzo\ del\ metodo\ update()}
\DoxyCodeLine{00114\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00115\ \ \ \ \ \}}
\DoxyCodeLine{00116\ }
\DoxyCodeLine{00117\ \ \ \ \ compressed\_data\_.clear();}
\DoxyCodeLine{00118\ \}}
\DoxyCodeLine{00119\ }
\DoxyCodeLine{00120\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00121\ template<NormType\ norm\_type>}
\DoxyCodeLine{00122\ T\ Matrix<T,\ Order>::norm()\ \{}
\DoxyCodeLine{00123\ //\ Computes\ the\ matrix\ norm\ (One,\ Infinity,\ or\ Frobenius)\ depending\ on\ the\ template\ parameter.}
\DoxyCodeLine{00124\ //\ Handles\ both\ compressed\ (CSR/CSC)\ and\ uncompressed\ (COOmap)\ storage\ formats,\ with\ automatic\ transposition\ if\ needed.}
\DoxyCodeLine{00125\ //\ Returns\ a\ scalar\ value\ representing\ the\ computed\ norm.}
\DoxyCodeLine{00126\ \ \ \ \ }
\DoxyCodeLine{00127\ \ \ \ \ T\ norm\ =\ T(0);}
\DoxyCodeLine{00128\ \ \ \ \ if\ (is\_compressed())\{}
\DoxyCodeLine{00129\ \ \ \ \ \ \ \ \ //\ Compressed\ case\ -\/\ CSR/CSC}
\DoxyCodeLine{00130\ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{00131\ \ \ \ \ \ \ \ \ bool\ was\_transposed\ =\ false;}
\DoxyCodeLine{00132\ \ \ \ \ \ \ \ \ if\ constexpr\ (norm\_type\ ==\ NormType::One)\ \{}
\DoxyCodeLine{00133\ \ \ \ \ \ \ \ \ \ \ \ \ if\ constexpr\ (Order\ ==\ StorageOrder::RowMajor)\{}
\DoxyCodeLine{00134\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ transpose();}
\DoxyCodeLine{00135\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ was\_transposed=true;}
\DoxyCodeLine{00136\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00137\ \ \ \ \ \ \ \ \ \ \ \ \ for\ (size\_t\ j\ =\ 0;\ j\ <\ cols\_;\ ++j)\ \{}
\DoxyCodeLine{00138\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ T\ col\_sum\ =\ T(0);}
\DoxyCodeLine{00139\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (size\_t\ idx\ =\ compressed\_data\_.outer\_ptr[j];\ idx\ <\ compressed\_data\_.outer\_ptr[j+1];\ ++idx)\ \{}
\DoxyCodeLine{00140\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ col\_sum\ +=\ std::abs(compressed\_data\_.values[idx]);}
\DoxyCodeLine{00141\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00142\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (std::abs(col\_sum)\ >\ std::abs(norm))\ \{norm\ =\ col\_sum;\}}
\DoxyCodeLine{00143\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00144\ \ \ \ \ \ \ \ \ \ \ \ \ if(was\_transposed)\{transpose();\}}
\DoxyCodeLine{00145\ \ \ \ \ \ \ \ \ \ \ \ \ return\ norm;}
\DoxyCodeLine{00146\ \ \ \ \ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{00147\ \ \ \ \ \ \ \ \ \}\ else\ if\ constexpr\ (norm\_type\ ==\ NormType::Infinity)\ \{}
\DoxyCodeLine{00148\ \ \ \ \ \ \ \ \ \ \ \ \ if\ constexpr\ (Order\ ==\ StorageOrder::ColumnMajor)\{}
\DoxyCodeLine{00149\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ transpose();}
\DoxyCodeLine{00150\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ was\_transposed=true;}
\DoxyCodeLine{00151\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00152\ \ \ \ \ \ \ \ \ \ \ \ \ for\ (size\_t\ j\ =\ 0;\ j\ <\ cols\_;\ ++j)\ \{}
\DoxyCodeLine{00153\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ T\ row\_sum\ =\ T(0);}
\DoxyCodeLine{00154\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (size\_t\ idx\ =\ compressed\_data\_.outer\_ptr[j];\ idx\ <\ compressed\_data\_.outer\_ptr[j+1];\ ++idx)\ \{}
\DoxyCodeLine{00155\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ row\_sum\ +=\ std::abs(compressed\_data\_.values[idx]);}
\DoxyCodeLine{00156\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00157\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (std::abs(row\_sum)\ >\ std::abs(norm))\ \{norm\ =\ row\_sum;\}}
\DoxyCodeLine{00158\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00159\ \ \ \ \ \ \ \ \ \ \ \ \ if(was\_transposed)\{transpose();\}}
\DoxyCodeLine{00160\ \ \ \ \ \ \ \ \ \ \ \ \ return\ norm;}
\DoxyCodeLine{00161\ \ \ \ \ \ \ \ \ \}\ else\ if\ constexpr\ (norm\_type\ ==\ NormType::Frobenius)\ \{}
\DoxyCodeLine{00162\ \ \ \ \ \ \ \ \ \ \ \ \ if\ constexpr\ (Order\ ==\ StorageOrder::ColumnMajor)\{}
\DoxyCodeLine{00163\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ transpose();}
\DoxyCodeLine{00164\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ was\_transposed=true;}
\DoxyCodeLine{00165\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00166\ \ \ \ \ \ \ \ \ \ \ \ \ for\ (size\_t\ j\ =\ 0;\ j\ <\ cols\_;\ ++j)\ \{}
\DoxyCodeLine{00167\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ T\ row\_sum\ =\ T(0);}
\DoxyCodeLine{00168\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (size\_t\ idx\ =\ compressed\_data\_.outer\_ptr[j];\ idx\ <\ compressed\_data\_.outer\_ptr[j+1];\ ++idx)\ \{}
\DoxyCodeLine{00169\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ row\_sum\ +=\ std::pow(std::abs(compressed\_data\_.values[idx]),T(2));}
\DoxyCodeLine{00170\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00171\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ norm\ +=\ row\_sum;}
\DoxyCodeLine{00172\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00173\ \ \ \ \ \ \ \ \ \ \ \ \ if(was\_transposed)\{transpose();\}}
\DoxyCodeLine{00174\ \ \ \ \ \ \ \ \ \ \ \ \ return\ std::sqrt(norm);}
\DoxyCodeLine{00175\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00176\ \ \ \ \ \}}
\DoxyCodeLine{00177\ \ \ \ \ else\ \{}
\DoxyCodeLine{00178\ \ \ \ \ \ \ \ \ //\ TO\ DO}
\DoxyCodeLine{00179\ \ \ \ \ \ \ \ \ //\ Uncompressed\ case\ -\/\ COOmap}
\DoxyCodeLine{00180\ \ \ \ \ \ \ \ \ if\ constexpr\ (norm\_type\ ==\ NormType::One)\ \{}
\DoxyCodeLine{00181\ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<T>\ col\_sums(cols\_,\ T(0));\ //\ empty\ vector\ of\ dimension\ cols\_}
\DoxyCodeLine{00182\ \ \ \ \ \ \ \ \ \ \ \ \ for(const\ auto\&\ [coord,\ value]\ :\ sparse\_data\_)\ \{}
\DoxyCodeLine{00183\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ col\_sums[coord[1]]\ +=\ std::abs(value);\ \ \ \ }
\DoxyCodeLine{00184\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00185\ \ \ \ \ \ \ \ \ \ \ \ \ for\ (const\ auto\&\ sum\ :\ col\_sums)\ \{}
\DoxyCodeLine{00186\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (std::abs(sum)\ >\ std::abs(norm))\ \{\ norm\ =\ sum;\ \}}
\DoxyCodeLine{00187\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ //\ needed\ to\ support\ also\ std::complex...}
\DoxyCodeLine{00188\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00189\ \ \ \ \ \ \ \ \ \ \ \ \ return\ norm;}
\DoxyCodeLine{00190\ \ \ \ \ \ \ \ \ \}\ else\ if\ constexpr\ (norm\_type\ ==\ NormType::Infinity)\ \{}
\DoxyCodeLine{00191\ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<T>\ row\_sums(rows\_,\ T(0));\ //\ empty\ vector\ of\ dimension\ rows\_}
\DoxyCodeLine{00192\ \ \ \ \ \ \ \ \ \ \ \ \ for(const\ auto\&\ [coord,\ value]\ :\ sparse\_data\_)\ \{}
\DoxyCodeLine{00193\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ row\_sums[coord[0]]\ +=\ std::abs(value);\ \ \ \ }
\DoxyCodeLine{00194\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00195\ \ \ \ \ \ \ \ \ \ \ \ \ for\ (const\ auto\&\ sum\ :\ row\_sums)\ \{}
\DoxyCodeLine{00196\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (std::abs(sum)\ >\ std::abs(norm))\ \{\ norm\ =\ sum;\ \}}
\DoxyCodeLine{00197\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ //\ needed\ to\ support\ also\ std::complex...}
\DoxyCodeLine{00198\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00199\ \ \ \ \ \ \ \ \ \ \ \ \ return\ norm;}
\DoxyCodeLine{00200\ \ \ \ \ \ \ \ \ \}\ else\ if\ constexpr\ (norm\_type\ ==\ NormType::Frobenius)\ \{}
\DoxyCodeLine{00201\ \ \ \ \ \ \ \ \ \ \ \ \ for(const\ auto\&\ [coord,\ value]\ :\ sparse\_data\_)\{}
\DoxyCodeLine{00202\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ norm\ +=\ std::pow(std::abs(value),\ T(2));}
\DoxyCodeLine{00203\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00204\ \ \ \ \ \ \ \ \ \ \ \ \ return\ std::sqrt(norm);}
\DoxyCodeLine{00205\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00206\ \ \ \ \ \}}
\DoxyCodeLine{00207\ \ \ \ \ }
\DoxyCodeLine{00208\ \}}
\DoxyCodeLine{00209\ }
\DoxyCodeLine{00210\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00211\ void\ Matrix<T,\ Order>::transpose()\ \{}
\DoxyCodeLine{00212\ //\ Transposes\ the\ matrix\ in-\/place\ by\ swapping\ rows\ and\ columns.}
\DoxyCodeLine{00213\ //\ Updates\ the\ sparse\ data\ (non-\/zero\ entries)\ by\ flipping\ their\ indices.}
\DoxyCodeLine{00214\ //\ Recompresses\ the\ matrix\ if\ it\ was\ previously\ compressed\ before\ transposing.}
\DoxyCodeLine{00215\ }
\DoxyCodeLine{00216\ \ \ \ \ //\ If\ compressed,\ decompress\ first}
\DoxyCodeLine{00217\ \ \ \ \ bool\ was\_compressed\ =\ false;}
\DoxyCodeLine{00218\ \ \ \ \ if\ (is\_compressed())\ \{}
\DoxyCodeLine{00219\ \ \ \ \ \ \ \ \ decompress();}
\DoxyCodeLine{00220\ \ \ \ \ \ \ \ \ was\_compressed\ =\ true;}
\DoxyCodeLine{00221\ \ \ \ \ \}}
\DoxyCodeLine{00222\ }
\DoxyCodeLine{00223\ \ \ \ \ //\ New\ sparse\_data\ where\ we\ will\ store\ transposed\ entries}
\DoxyCodeLine{00224\ \ \ \ \ std::map<std::array<size\_t,\ 2>,\ T>\ new\_sparse\_data;}
\DoxyCodeLine{00225\ }
\DoxyCodeLine{00226\ \ \ \ \ for\ (const\ auto\&\ [key,\ value]\ :\ sparse\_data\_)\ \{}
\DoxyCodeLine{00227\ \ \ \ \ \ \ \ \ std::array<size\_t,\ 2>\ transposed\_key\ =\ \{key[1],\ key[0]\};\ //\ flip\ (i,j)\ -\/>\ (j,i)}
\DoxyCodeLine{00228\ \ \ \ \ \ \ \ \ new\_sparse\_data[transposed\_key]\ =\ value;}
\DoxyCodeLine{00229\ \ \ \ \ \}}
\DoxyCodeLine{00230\ }
\DoxyCodeLine{00231\ \ \ \ \ //\ Swap\ rows\ and\ columns}
\DoxyCodeLine{00232\ \ \ \ \ std::swap(rows\_,\ cols\_);}
\DoxyCodeLine{00233\ }
\DoxyCodeLine{00234\ \ \ \ \ //\ Replace\ old\ sparse\ data\ with\ the\ transposed\ one}
\DoxyCodeLine{00235\ \ \ \ \ sparse\_data\_\ =\ std::move(new\_sparse\_data);}
\DoxyCodeLine{00236\ }
\DoxyCodeLine{00237\ \ \ \ \ //\ If\ it\ was\ compressed\ in\ the\ beginning,\ recompress\ it}
\DoxyCodeLine{00238\ \ \ \ \ if(was\_compressed)\{compress();\}}
\DoxyCodeLine{00239\ \}}
\DoxyCodeLine{00240\ }
\DoxyCodeLine{00241\ //\ Product\ by\ Vector\ methods}
\DoxyCodeLine{00242\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00243\ std::vector<T>\ Matrix<T,\ Order>::compressed\_product\_by\_vector\_parallel(const\ std::vector<T>\&\ v)\ const\ \{}
\DoxyCodeLine{00244\ //\ Multiplies\ a\ compressed\ matrix\ by\ a\ vector\ v\ using\ parallelization\ for\ faster\ computation.}
\DoxyCodeLine{00245\ //\ Uses\ OpenMP\ to\ parallelize\ the\ dot\ product\ calculation\ for\ each\ row\ of\ the\ matrix.}
\DoxyCodeLine{00246\ //\ Inputs:\ v\ -\/\ a\ vector\ of\ type\ T,\ Outputs:\ a\ vector\ of\ type\ T\ with\ the\ result\ of\ the\ multiplication.}
\DoxyCodeLine{00247\ }
\DoxyCodeLine{00248\ \ \ \ \ std::vector<T>\ output(rows\_,\ T(0));}
\DoxyCodeLine{00249\ }
\DoxyCodeLine{00250\ \ \ \ \ if\ constexpr\ (Order\ ==\ StorageOrder::RowMajor)\ \{}
\DoxyCodeLine{00251\ \ \ \ \ \ \ \ \ //\ RowMajor\ (CSR):\ traverse\ row\ by\ row\ (parallelized)}
\DoxyCodeLine{00252\ \ \ \ \ \ \ \ \ \#pragma\ omp\ parallel\ for}
\DoxyCodeLine{00253\ \ \ \ \ \ \ \ \ for\ (size\_t\ i\ =\ 0;\ i\ <\ rows\_;\ ++i)\ \{}
\DoxyCodeLine{00254\ \ \ \ \ \ \ \ \ \ \ \ \ T\ sum\ =\ 0;}
\DoxyCodeLine{00255\ \ \ \ \ \ \ \ \ \ \ \ \ for\ (size\_t\ k\ =\ compressed\_data\_.outer\_ptr[i];\ k\ <\ compressed\_data\_.outer\_ptr[i\ +\ 1];\ ++k)\ \{}
\DoxyCodeLine{00256\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sum\ +=\ compressed\_data\_.values[k]\ *\ v[compressed\_data\_.inner\_index[k]];}
\DoxyCodeLine{00257\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00258\ \ \ \ \ \ \ \ \ \ \ \ \ output[i]\ =\ sum;}
\DoxyCodeLine{00259\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00260\ \ \ \ \ \}\ else\ \{}
\DoxyCodeLine{00261\ \ \ \ \ \ \ \ \ //\ ColumnMajor\ (CSC):\ traverse\ column\ by\ column}
\DoxyCodeLine{00262\ \ \ \ \ \ \ \ \ \#pragma\ omp\ parallel\ for}
\DoxyCodeLine{00263\ \ \ \ \ \ \ \ \ for\ (size\_t\ j\ =\ 0;\ j\ <\ cols\_;\ ++j)\ \{}
\DoxyCodeLine{00264\ \ \ \ \ \ \ \ \ \ \ \ \ for\ (size\_t\ k\ =\ compressed\_data\_.outer\_ptr[j];\ k\ <\ compressed\_data\_.outer\_ptr[j\ +\ 1];\ ++k)\ \{}
\DoxyCodeLine{00265\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size\_t\ i\ =\ compressed\_data\_.inner\_index[k];}
\DoxyCodeLine{00266\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \#pragma\ omp\ atomic}
\DoxyCodeLine{00267\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ output[i]\ +=\ compressed\_data\_.values[k]\ *\ v[j];}
\DoxyCodeLine{00268\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00269\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00270\ \ \ \ \ \}}
\DoxyCodeLine{00271\ }
\DoxyCodeLine{00272\ \ \ \ \ return\ output;}
\DoxyCodeLine{00273\ \}}
\DoxyCodeLine{00274\ }
\DoxyCodeLine{00275\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00276\ std::vector<T>\ Matrix<T,\ Order>::compressed\_product\_by\_vector(const\ std::vector<T>\&\ v)\ const\ \{}
\DoxyCodeLine{00277\ \ \ \ \ std::vector<T>\ output(rows\_,\ T(0));}
\DoxyCodeLine{00278\ }
\DoxyCodeLine{00279\ \ \ \ \ if\ constexpr\ (Order\ ==\ StorageOrder::RowMajor)\ \{}
\DoxyCodeLine{00280\ \ \ \ \ \ \ \ \ //\ RowMajor\ (CSR):\ traverse\ row\ by\ row}
\DoxyCodeLine{00281\ \ \ \ \ \ \ \ \ for\ (size\_t\ i\ =\ 0;\ i\ <\ rows\_;\ ++i)\ \{}
\DoxyCodeLine{00282\ \ \ \ \ \ \ \ \ \ \ \ \ T\ sum\ =\ 0;}
\DoxyCodeLine{00283\ \ \ \ \ \ \ \ \ \ \ \ \ for\ (size\_t\ k\ =\ compressed\_data\_.outer\_ptr[i];\ k\ <\ compressed\_data\_.outer\_ptr[i\ +\ 1];\ ++k)\ \{}
\DoxyCodeLine{00284\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sum\ +=\ compressed\_data\_.values[k]\ *\ v[compressed\_data\_.inner\_index[k]];}
\DoxyCodeLine{00285\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00286\ \ \ \ \ \ \ \ \ \ \ \ \ output[i]\ =\ sum;}
\DoxyCodeLine{00287\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00288\ \ \ \ \ \}\ else\ \{}
\DoxyCodeLine{00289\ \ \ \ \ \ \ \ \ //\ ColumnMajor\ (CSC):\ traverse\ column\ by\ column}
\DoxyCodeLine{00290\ \ \ \ \ \ \ \ \ for\ (size\_t\ j\ =\ 0;\ j\ <\ cols\_;\ ++j)\ \{}
\DoxyCodeLine{00291\ \ \ \ \ \ \ \ \ \ \ \ \ for\ (size\_t\ k\ =\ compressed\_data\_.outer\_ptr[j];\ k\ <\ compressed\_data\_.outer\_ptr[j\ +\ 1];\ ++k)\ \{}
\DoxyCodeLine{00292\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size\_t\ i\ =\ compressed\_data\_.inner\_index[k];}
\DoxyCodeLine{00293\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ output[i]\ +=\ compressed\_data\_.values[k]\ *\ v[j];}
\DoxyCodeLine{00294\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00295\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00296\ \ \ \ \ \}}
\DoxyCodeLine{00297\ }
\DoxyCodeLine{00298\ \ \ \ \ return\ output;}
\DoxyCodeLine{00299\ \}}
\DoxyCodeLine{00300\ }
\DoxyCodeLine{00301\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00302\ std::vector<T>\ Matrix<T,\ Order>::product\_by\_vector(const\ std::vector<T>\&\ v)\ const\ \{}
\DoxyCodeLine{00303\ //\ Multiplies\ the\ matrix\ by\ a\ vector\ v.\ If\ the\ matrix\ is\ compressed,\ it\ uses\ either\ parallel\ or\ regular\ multiplication\ based\ on\ the\ number\ of\ rows\ (CSR\ case)\ or\ columns\ (CSC\ case).\ }
\DoxyCodeLine{00304\ //\ For\ uncompressed\ matrices\ in\ COO\ format,\ it\ performs\ the\ multiplication\ by\ iterating\ over\ sparse\ data.}
\DoxyCodeLine{00305\ //\ Inputs:\ v\ -\/\ a\ vector\ of\ type\ T,\ Outputs:\ a\ vector\ of\ type\ T\ with\ the\ result\ of\ the\ multiplication.}
\DoxyCodeLine{00306\ }
\DoxyCodeLine{00307\ \ \ \ \ if\ (is\_compressed())\ \{}
\DoxyCodeLine{00308\ \ \ \ \ \ \ \ \ if\ constexpr\ (Order==StorageOrder::RowMajor)\{}
\DoxyCodeLine{00309\ \ \ \ \ \ \ \ \ \ \ \ \ if\ (rows\_>=params::NROWS\_PARALLELIZATON\_LIMIT)\{}
\DoxyCodeLine{00310\ \ \ \ \ \ \ \ \ \ \ \ \ return\ compressed\_product\_by\_vector\_parallel(v);}
\DoxyCodeLine{00311\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00312\ \ \ \ \ \ \ \ \ \ \ \ \ else\{}
\DoxyCodeLine{00313\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ compressed\_product\_by\_vector(v);}
\DoxyCodeLine{00314\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00315\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00316\ \ \ \ \ \ \ \ \ else\{}
\DoxyCodeLine{00317\ \ \ \ \ \ \ \ \ \ \ \ \ if\ (rows\_>=params::NCOLS\_PARALLELIZATON\_LIMIT)\{}
\DoxyCodeLine{00318\ \ \ \ \ \ \ \ \ \ \ \ \ return\ compressed\_product\_by\_vector\_parallel(v);}
\DoxyCodeLine{00319\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00320\ \ \ \ \ \ \ \ \ \ \ \ \ else\{}
\DoxyCodeLine{00321\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ compressed\_product\_by\_vector(v);}
\DoxyCodeLine{00322\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00323\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00324\ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{00325\ \ \ \ \ \}}
\DoxyCodeLine{00326\ \ \ \ \ else\ \{}
\DoxyCodeLine{00327\ \ \ \ \ \ \ \ \ //\ Create\ the\ output\ vector\ }
\DoxyCodeLine{00328\ \ \ \ \ \ \ \ \ std::vector<T>\ output(rows\_,\ 0);}
\DoxyCodeLine{00329\ }
\DoxyCodeLine{00330\ \ \ \ \ \ \ \ \ //\ Uncompressed\ multiplication\ (COO)}
\DoxyCodeLine{00331\ \ \ \ \ \ \ \ \ for\ (const\ auto\&\ [key,\ val]\ :\ sparse\_data\_)\ \{}
\DoxyCodeLine{00332\ \ \ \ \ \ \ \ \ \ \ \ \ size\_t\ i\ =\ key[0];}
\DoxyCodeLine{00333\ \ \ \ \ \ \ \ \ \ \ \ \ size\_t\ j\ =\ key[1];}
\DoxyCodeLine{00334\ \ \ \ \ \ \ \ \ \ \ \ \ output[i]\ +=\ val\ *\ v[j];}
\DoxyCodeLine{00335\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00336\ \ \ \ \ \ \ \ \ return\ output;}
\DoxyCodeLine{00337\ \ \ \ \ \}}
\DoxyCodeLine{00338\ }
\DoxyCodeLine{00339\ \}}
\DoxyCodeLine{00340\ }
\DoxyCodeLine{00341\ template<typename\ T,\ StorageOrder\ Order>\ //\ This\ function\ applies\ to\ any\ Matrix\ type\ with\ any\ storage\ order}
\DoxyCodeLine{00342\ std::vector<T>\ Matrix<T,\ Order>::operator*(const\ Matrix<T,\ Order>\&\ rhs)\ const\ \{//\ The\ result\ is\ a\ plain\ std::vector<T>,\ representing\ the\ product\ result}
\DoxyCodeLine{00343\ //\ Overloads\ the\ *\ operator\ to\ perform\ matrix-\/vector\ multiplication\ when\ rhs\ is\ a\ column\ vector\ matrix.}
\DoxyCodeLine{00344\ //\ Assumes\ rhs\ is\ effectively\ a\ column\ vector;\ converts\ it\ to\ std::vector<T>\ and\ uses\ product\_by\_vector\ for\ the\ computation.}
\DoxyCodeLine{00345\ //\ Ensures\ rhs\ is\ in\ uncompressed\ form\ before\ extracting\ values.}
\DoxyCodeLine{00346\ }
\DoxyCodeLine{00347\ \ \ \ \ //Check\ dimension\ compatibility}
\DoxyCodeLine{00348\ \ \ \ \ if\ (cols\_\ !=\ rhs.rows\_)\ \{\ }
\DoxyCodeLine{00349\ \ \ \ \ \ \ \ \ throw\ std::invalid\_argument("{}Matrix\ dimensions\ do\ not\ match\ for\ multiplication."{});}
\DoxyCodeLine{00350\ \ \ \ \ \}}
\DoxyCodeLine{00351\ }
\DoxyCodeLine{00352\ \ \ \ \ //Convert\ rhs\ into\ a\ std::vector<T>}
\DoxyCodeLine{00353\ \ \ \ \ std::vector<T>\ vec(rhs.rows\_,\ 0);}
\DoxyCodeLine{00354\ }
\DoxyCodeLine{00355\ \ \ \ //\ Make\ sure\ rhs\ is\ decompressed}
\DoxyCodeLine{00356\ \ \ \ \ if\ (rhs.is\_compressed())\ \{}
\DoxyCodeLine{00357\ \ \ \ \ \ \ \ \ Matrix<T,\ Order>\ rhs\_copy\ =\ rhs;//\ We\ cannot\ modify\ rhs\ (it's\ a\ const\ reference),\ so\ we\ create\ a\ copy}
\DoxyCodeLine{00358\ \ \ \ \ \ \ \ \ rhs\_copy.decompress();}
\DoxyCodeLine{00359\ \ \ \ \ \ \ \ \ for\ (const\ auto\&\ [key,\ val]\ :\ rhs\_copy.sparse\_data\_)\ \{}
\DoxyCodeLine{00360\ \ \ \ \ \ \ \ \ \ \ \ \ vec[key[0]]\ =\ val;\ //\ key[0]\ represents\ the\ row\ index\ (since\ rhs\ is\ a\ column\ vector)}
\DoxyCodeLine{00361\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00362\ \ \ \ \ \}\ else\ \{}
\DoxyCodeLine{00363\ \ \ \ \ \ \ \ \ for\ (const\ auto\&\ [key,\ val]\ :\ rhs.sparse\_data\_)\ \{}
\DoxyCodeLine{00364\ \ \ \ \ \ \ \ \ \ \ \ \ vec[key[0]]\ =\ val;\ //\ If\ already\ uncompressed,\ directly\ extract\ values\ from\ sparse\_data\_}
\DoxyCodeLine{00365\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00366\ \ \ \ \ \}}
\DoxyCodeLine{00367\ \ \ \ \ //\ Use\ existing\ method\ to\ perform\ matrix-\/vector\ multiplication}
\DoxyCodeLine{00368\ \ \ \ \ return\ this-\/>product\_by\_vector(vec);}
\DoxyCodeLine{00369\ \}}
\DoxyCodeLine{00370\ }
\DoxyCodeLine{00371\ //\ MATRIX\ MARKET\ PARSER\ +\ LOADER\ METHODS}
\DoxyCodeLine{00372\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00373\ bool\ Matrix<T,\ Order>::mm\_stringstream\_to\_sparsedata\_loader(const\ std::istringstream\&\ iss\_original)\{}
\DoxyCodeLine{00374\ //\ Parses\ a\ Matrix\ Market\ file's\ content\ (from\ a\ stringstream)\ into\ sparse\ matrix\ data\ format.}
\DoxyCodeLine{00375\ //\ Reads\ the\ header\ to\ get\ matrix\ dimensions,\ then\ processes\ triplets\ (row,\ column,\ value)\ to\ populate\ the\ matrix.}
\DoxyCodeLine{00376\ //\ Inputs:\ iss\_original\ -\/\ an\ input\ stringstream\ containing\ the\ file\ content,\ Outputs:\ true\ if\ parsing\ is\ successful,\ false\ otherwise.}
\DoxyCodeLine{00377\ }
\DoxyCodeLine{00378\ \ \ \ \ std::istringstream\ iss(iss\_original.str());\ //\ fai\ una\ copia\ per\ poter\ usare\ getline\ e\ >>\ separatamente}
\DoxyCodeLine{00379\ \ \ \ \ std::string\ line;}
\DoxyCodeLine{00380\ \ \ \ \ int\ max\_row\_idx\ =\ 0;}
\DoxyCodeLine{00381\ \ \ \ \ int\ max\_col\_idx\ =\ 0;}
\DoxyCodeLine{00382\ }
\DoxyCodeLine{00383\ \ \ \ \ //\ Skip\ header\ and\ comments}
\DoxyCodeLine{00384\ \ \ \ \ while\ (std::getline(iss,\ line))\ \{}
\DoxyCodeLine{00385\ \ \ \ \ \ \ \ \ if\ (line.empty()\ ||\ line[0]\ ==\ '\%')\ continue;}
\DoxyCodeLine{00386\ \ \ \ \ \ \ \ \ else\ break;\ //\ first\ non-\/comment\ line}
\DoxyCodeLine{00387\ \ \ \ \ \}}
\DoxyCodeLine{00388\ }
\DoxyCodeLine{00389\ \ \ \ \ //\ parse\ dimensions}
\DoxyCodeLine{00390\ \ \ \ \ std::istringstream\ header\_line(line);}
\DoxyCodeLine{00391\ \ \ \ \ size\_t\ rows,\ cols,\ entries;}
\DoxyCodeLine{00392\ \ \ \ \ if\ (!(header\_line\ >>\ rows\ >>\ cols\ >>\ entries))\ \{}
\DoxyCodeLine{00393\ \ \ \ \ \ \ \ \ std::cerr\ <<\ "{}Error\ parsing\ header\ line:\ "{}\ <<\ line\ <<\ std::endl;}
\DoxyCodeLine{00394\ \ \ \ \ \ \ \ \ return\ false;}
\DoxyCodeLine{00395\ \ \ \ \ \}}
\DoxyCodeLine{00396\ }
\DoxyCodeLine{00397\ \ \ \ \ //\ parse\ triplets}
\DoxyCodeLine{00398\ \ \ \ \ int\ row,\ col;}
\DoxyCodeLine{00399\ \ \ \ \ double\ value;}
\DoxyCodeLine{00400\ \ \ \ \ while\ (iss\ >>\ row\ >>\ col\ >>\ value)\ \{}
\DoxyCodeLine{00401\ \ \ \ \ \ \ \ \ if\ (row\ >\ max\_row\_idx)\ max\_row\_idx\ =\ row;}
\DoxyCodeLine{00402\ \ \ \ \ \ \ \ \ if\ (col\ >\ max\_col\_idx)\ max\_col\_idx\ =\ col;}
\DoxyCodeLine{00403\ \ \ \ \ \ \ \ \ update(row\ -\/\ 1,\ col\ -\/\ 1,\ value);\ //\ Matrix\ Market\ is\ 1-\/based}
\DoxyCodeLine{00404\ \ \ \ \ \}}
\DoxyCodeLine{00405\ }
\DoxyCodeLine{00406\ \ \ \ \ rows\_\ =\ static\_cast<size\_t>(max\_row\_idx);}
\DoxyCodeLine{00407\ \ \ \ \ cols\_\ =\ static\_cast<size\_t>(max\_col\_idx);}
\DoxyCodeLine{00408\ }
\DoxyCodeLine{00409\ \ \ \ \ return\ true;}
\DoxyCodeLine{00410\ \}}
\DoxyCodeLine{00411\ }
\DoxyCodeLine{00412\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00413\ std::string\ Matrix<T,\ Order>::mm\_extract\_gz(const\ std::string\&\ filename)\{}
\DoxyCodeLine{00414\ //\ Extracts\ and\ reads\ the\ contents\ of\ a\ compressed\ (.gz)\ Matrix\ Market\ file.}
\DoxyCodeLine{00415\ //\ Uses\ zlib's\ gz\ functions\ to\ read\ the\ file\ in\ chunks\ and\ accumulate\ its\ contents\ into\ a\ string.}
\DoxyCodeLine{00416\ //\ Inputs:\ filename\ -\/\ the\ file\ path,\ Outputs:\ the\ content\ of\ the\ file\ as\ a\ string.}
\DoxyCodeLine{00417\ }
\DoxyCodeLine{00418\ \ \ \ \ gzFile\ file\ =\ gzopen(filename.c\_str(),\ "{}rb"{});}
\DoxyCodeLine{00419\ \ \ \ \ if\ (!file)\ \{}
\DoxyCodeLine{00420\ \ \ \ \ \ \ \ \ std::cerr\ <<\ "{}Error:\ could\ not\ open\ file\ "{}\ <<\ filename\ <<\ std::endl;}
\DoxyCodeLine{00421\ \ \ \ \ \ \ \ \ return\ "{}"{};}
\DoxyCodeLine{00422\ \ \ \ \ \}}
\DoxyCodeLine{00423\ \ \ \ \ }
\DoxyCodeLine{00424\ }
\DoxyCodeLine{00425\ \ \ \ \ }
\DoxyCodeLine{00426\ \ \ \ \ char\ buffer[params::BUFFER\_SIZE];}
\DoxyCodeLine{00427\ }
\DoxyCodeLine{00428\ \ \ \ \ std::string\ file\_content;}
\DoxyCodeLine{00429\ }
\DoxyCodeLine{00430\ \ \ \ \ int\ bytes\_read;}
\DoxyCodeLine{00431\ \ \ \ \ while\ ((bytes\_read\ =\ gzread(file,\ buffer,\ params::BUFFER\_SIZE\ -\/\ 1))\ >\ 0)\ \{}
\DoxyCodeLine{00432\ \ \ \ \ \ \ \ \ buffer[bytes\_read]\ =\ '\(\backslash\)0';\ //\ Null-\/terminate\ buffer}
\DoxyCodeLine{00433\ \ \ \ \ \ \ \ \ file\_content\ +=\ buffer;\ \ \ \ //\ Accumulate\ contents}
\DoxyCodeLine{00434\ \ \ \ \ \}}
\DoxyCodeLine{00435\ }
\DoxyCodeLine{00436\ \ \ \ \ gzclose(file);}
\DoxyCodeLine{00437\ \ \ \ \ return\ file\_content;}
\DoxyCodeLine{00438\ \}}
\DoxyCodeLine{00439\ }
\DoxyCodeLine{00440\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00441\ bool\ Matrix<T,\ Order>::mm\_load\_mtx(const\ std::string\&\ filename)\{}
\DoxyCodeLine{00442\ //\ Loads\ a\ Matrix\ Market\ (.mtx\ or\ .mtx.gz)\ file\ and\ parses\ its\ contents\ into\ sparse\ data\ format.}
\DoxyCodeLine{00443\ //\ Supports\ both\ compressed\ (.mtx.gz)\ and\ uncompressed\ (.mtx)\ Matrix\ Market\ files.}
\DoxyCodeLine{00444\ //\ Inputs:\ filename\ -\/\ the\ file\ path,\ Outputs:\ true\ if\ loading\ is\ successful,\ false\ otherwise.}
\DoxyCodeLine{00445\ }
\DoxyCodeLine{00446\ \ \ \ \ }
\DoxyCodeLine{00447\ \ \ \ \ if\ (filename.ends\_with("{}.mtx.gz"{}))\ \{}
\DoxyCodeLine{00448\ \ \ \ \ \ \ \ \ sparse\_data\_.clear();\ //\ clear\ sparse\_data\_\ values}
\DoxyCodeLine{00449\ \ \ \ \ \ \ \ \ compressed\_data\_.clear();\ //\ clear\ compressed\ data\ values}
\DoxyCodeLine{00450\ }
\DoxyCodeLine{00451\ \ \ \ \ \ \ \ \ auto\ file\_content\ =\ mm\_extract\_gz(filename);}
\DoxyCodeLine{00452\ \ \ \ \ \ \ \ \ std::istringstream\ iss(file\_content);}
\DoxyCodeLine{00453\ \ \ \ \ \ \ \ \ return\ mm\_stringstream\_to\_sparsedata\_loader(iss);}
\DoxyCodeLine{00454\ \ \ \ \ \}\ }
\DoxyCodeLine{00455\ \ \ \ \ else\ if\ (filename.ends\_with("{}.mtx"{}))\ \{}
\DoxyCodeLine{00456\ \ \ \ \ \ \ \ \ sparse\_data\_.clear();\ //\ clear\ sparse\_data\_\ values}
\DoxyCodeLine{00457\ \ \ \ \ \ \ \ \ compressed\_data\_.clear();\ //\ clear\ compressed\ data\ values}
\DoxyCodeLine{00458\ }
\DoxyCodeLine{00459\ \ \ \ \ \ \ \ \ std::ifstream\ ifs(filename);}
\DoxyCodeLine{00460\ \ \ \ \ \ \ \ \ if\ (!ifs.is\_open())\ \{}
\DoxyCodeLine{00461\ \ \ \ \ \ \ \ \ \ \ \ \ std::cerr\ <<\ "{}Error:\ could\ not\ open\ file\ "{}\ <<\ filename\ <<\ std::endl;}
\DoxyCodeLine{00462\ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;}
\DoxyCodeLine{00463\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00464\ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{00465\ \ \ \ \ \ \ \ \ //\ Leggi\ il\ contenuto\ del\ file\ direttamente\ in\ un\ istringstream}
\DoxyCodeLine{00466\ \ \ \ \ \ \ \ \ std::istringstream\ iss;}
\DoxyCodeLine{00467\ \ \ \ \ \ \ \ \ iss.str(std::string((std::istreambuf\_iterator<char>(ifs)),\ std::istreambuf\_iterator<char>()));}
\DoxyCodeLine{00468\ }
\DoxyCodeLine{00469\ \ \ \ \ \ \ \ \ return\ mm\_stringstream\_to\_sparsedata\_loader(iss);}
\DoxyCodeLine{00470\ \ \ \ \ \}}
\DoxyCodeLine{00471\ \ \ \ \ else\{}
\DoxyCodeLine{00472\ \ \ \ \ \ \ \ \ std::cout\ <<\ "{}Not\ a\ Matrix\ Market\ file..."{}\ <<\ std::endl;}
\DoxyCodeLine{00473\ \ \ \ \ \ \ \ \ return\ false;}
\DoxyCodeLine{00474\ \ \ \ \ \}}
\DoxyCodeLine{00475\ \ \ \ \ }
\DoxyCodeLine{00476\ \}}
\DoxyCodeLine{00477\ \ \ \ \ }
\DoxyCodeLine{00478\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00479\ void\ Matrix<T,\ Order>::resize(size\_t\ new\_rows,\ size\_t\ new\_cols)\ \{}
\DoxyCodeLine{00480\ //\ Resizes\ the\ matrix\ to\ new\_rows\ x\ new\_cols,\ updating\ internal\ dimensions.}
\DoxyCodeLine{00481\ //\ Removes\ all\ elements\ outside\ the\ new\ bounds.}
\DoxyCodeLine{00482\ //\ INPUT:\ new\_rows\ (size\_t),\ new\_cols\ (size\_t)\ -\/\ new\ dimensions;\ OUTPUT:\ none\ (matrix\ modified\ in-\/place).}
\DoxyCodeLine{00483\ }
\DoxyCodeLine{00484\ \ \ \ \ bool\ was\_compressed\ =\ false;}
\DoxyCodeLine{00485\ \ \ \ \ if\ (is\_compressed())\{}
\DoxyCodeLine{00486\ \ \ \ \ \ \ \ \ decompress();}
\DoxyCodeLine{00487\ \ \ \ \ \ \ \ \ was\_compressed\ =\ true;}
\DoxyCodeLine{00488\ \ \ \ \ \}}
\DoxyCodeLine{00489\ \ \ \ \ rows\_\ =\ new\_rows;}
\DoxyCodeLine{00490\ \ \ \ \ cols\_\ =\ new\_cols;}
\DoxyCodeLine{00491\ }
\DoxyCodeLine{00492\ \ \ \ \ //\ Remove\ entries\ that\ are\ now\ out\ of\ bounds}
\DoxyCodeLine{00493\ \ \ \ \ for\ (auto\ it\ =\ sparse\_data\_.begin();\ it\ !=\ sparse\_data\_.end();\ )\ \{}
\DoxyCodeLine{00494\ \ \ \ \ \ \ \ \ auto\ [row,\ col]\ =\ it-\/>first;}
\DoxyCodeLine{00495\ \ \ \ \ \ \ \ \ if\ (row\ >=\ new\_rows\ ||\ col\ >=\ new\_cols)\ \{}
\DoxyCodeLine{00496\ \ \ \ \ \ \ \ \ \ \ \ \ it\ =\ sparse\_data\_.erase(it);\ \ //\ erase\ returns\ the\ next\ valid\ iterator}
\DoxyCodeLine{00497\ \ \ \ \ \ \ \ \ \}\ else\ \{}
\DoxyCodeLine{00498\ \ \ \ \ \ \ \ \ \ \ \ \ ++it;}
\DoxyCodeLine{00499\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00500\ \ \ \ \ \}}
\DoxyCodeLine{00501\ }
\DoxyCodeLine{00502\ \ \ \ \ if\ (was\_compressed)\{}
\DoxyCodeLine{00503\ \ \ \ \ \ \ \ \ compress();}
\DoxyCodeLine{00504\ \ \ \ \ \}}
\DoxyCodeLine{00505\ \}}
\DoxyCodeLine{00506\ }
\DoxyCodeLine{00507\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00508\ std::vector<T>\ Matrix<T,\ Order>::diagonal\_view()\ const\ \{}
\DoxyCodeLine{00509\ //\ Returns\ a\ vector\ containing\ the\ diagonal\ elements\ of\ the\ matrix.}
\DoxyCodeLine{00510\ //\ If\ an\ element\ on\ the\ diagonal\ is\ not\ stored\ explicitly\ (i.e.,\ zero\ in\ sparse\ form),\ we\ assume\ it\ is\ 0.}
\DoxyCodeLine{00511\ }
\DoxyCodeLine{00512\ \ \ \ \ std::vector<T>\ diag(std::min(rows\_,\ cols\_),\ T(0));}
\DoxyCodeLine{00513\ }
\DoxyCodeLine{00514\ \ \ \ \ if\ (!is\_compressed())\ \{}
\DoxyCodeLine{00515\ \ \ \ \ \ \ \ \ //\ Uncompressed\ (COO\ map)\ case}
\DoxyCodeLine{00516\ \ \ \ \ \ \ \ \ for\ (size\_t\ i\ =\ 0;\ i\ <\ diag.size();\ ++i)\ \{}
\DoxyCodeLine{00517\ \ \ \ \ \ \ \ \ \ \ \ \ std::array<size\_t,\ 2>\ key\ =\ \{i,\ i\};}
\DoxyCodeLine{00518\ \ \ \ \ \ \ \ \ \ \ \ \ auto\ it\ =\ sparse\_data\_.find(key);}
\DoxyCodeLine{00519\ \ \ \ \ \ \ \ \ \ \ \ \ if\ (it\ !=\ sparse\_data\_.end())\ \{}
\DoxyCodeLine{00520\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ diag[i]\ =\ it-\/>second;}
\DoxyCodeLine{00521\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00522\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00523\ \ \ \ \ \}\ else\ \{}
\DoxyCodeLine{00524\ \ \ \ \ \ \ \ \ //\ Compressed\ (CSR/CSC)\ case}
\DoxyCodeLine{00525\ \ \ \ \ \ \ \ \ constexpr\ bool\ isRowMajor\ =\ (Order\ ==\ StorageOrder::RowMajor);}
\DoxyCodeLine{00526\ }
\DoxyCodeLine{00527\ \ \ \ \ \ \ \ \ if\ (isRowMajor)\ \{}
\DoxyCodeLine{00528\ \ \ \ \ \ \ \ \ \ \ \ \ for\ (size\_t\ i\ =\ 0;\ i\ <\ diag.size();\ ++i)\ \{}
\DoxyCodeLine{00529\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (size\_t\ k\ =\ compressed\_data\_.outer\_ptr[i];\ k\ <\ compressed\_data\_.outer\_ptr[i\ +\ 1];\ ++k)\ \{}
\DoxyCodeLine{00530\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (compressed\_data\_.inner\_index[k]\ ==\ i)\ \{}
\DoxyCodeLine{00531\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ diag[i]\ =\ compressed\_data\_.values[k];}
\DoxyCodeLine{00532\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break;}
\DoxyCodeLine{00533\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00534\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00535\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00536\ \ \ \ \ \ \ \ \ \}\ else\ \{}
\DoxyCodeLine{00537\ \ \ \ \ \ \ \ \ \ \ \ \ for\ (size\_t\ j\ =\ 0;\ j\ <\ diag.size();\ ++j)\ \{}
\DoxyCodeLine{00538\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for\ (size\_t\ k\ =\ compressed\_data\_.outer\_ptr[j];\ k\ <\ compressed\_data\_.outer\_ptr[j\ +\ 1];\ ++k)\ \{}
\DoxyCodeLine{00539\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (compressed\_data\_.inner\_index[k]\ ==\ j)\ \{}
\DoxyCodeLine{00540\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ diag[j]\ =\ compressed\_data\_.values[k];}
\DoxyCodeLine{00541\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break;}
\DoxyCodeLine{00542\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00543\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00544\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00545\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00546\ \ \ \ \ \}}
\DoxyCodeLine{00547\ }
\DoxyCodeLine{00548\ \ \ \ \ return\ diag;}
\DoxyCodeLine{00549\ \}}
\DoxyCodeLine{00550\ }
\DoxyCodeLine{00551\ }
\DoxyCodeLine{00552\ }
\DoxyCodeLine{00553\ //\ ‚ÑπÔ∏è\ INFO\ \&\ PRINTING\ METHODS}
\DoxyCodeLine{00554\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00555\ void\ Matrix<T,\ Order>::print(int\ width)\ const\ \{}
\DoxyCodeLine{00556\ \ \ \ \ //\ Prints\ the\ matrix\ in\ a\ tabular,\ human-\/readable\ form.}
\DoxyCodeLine{00557\ \ \ \ \ //\ If\ the\ matrix\ is\ uncompressed,\ it\ prints\ from\ sparse\_data\_.}
\DoxyCodeLine{00558\ \ \ \ \ //\ If\ compressed,\ it\ reconstructs\ the\ row-\/wise\ representation\ using\ compressed\_data\_.}
\DoxyCodeLine{00559\ \ \ \ \ //\ Parameters:}
\DoxyCodeLine{00560\ \ \ \ \ //\ \ \ width\ (optional):\ number\ of\ characters\ per\ column\ (default\ =\ 6,\ see\ Matrix.hpp).}
\DoxyCodeLine{00561\ }
\DoxyCodeLine{00562\ \ \ \ \ if\ (!is\_compressed())\ \{}
\DoxyCodeLine{00563\ \ \ \ \ \ \ \ \ //\ Uncompressed\ mode}
\DoxyCodeLine{00564\ \ \ \ \ \ \ \ \ for\ (std::size\_t\ i\ =\ 0;\ i\ <\ rows\_;\ ++i)\ \{}
\DoxyCodeLine{00565\ \ \ \ \ \ \ \ \ \ \ \ \ for\ (std::size\_t\ j\ =\ 0;\ j\ <\ cols\_;\ ++j)\ \{}
\DoxyCodeLine{00566\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::array<size\_t,\ 2>\ key\ =\ \{i,\ j\};}
\DoxyCodeLine{00567\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (sparse\_data\_.count(key))\ \{}
\DoxyCodeLine{00568\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ std::setw(width)\ <<\ sparse\_data\_.at(key);}
\DoxyCodeLine{00569\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ else\ \{}
\DoxyCodeLine{00570\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ std::setw(width)\ <<\ T(0);}
\DoxyCodeLine{00571\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00572\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00573\ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ '\(\backslash\)n';}
\DoxyCodeLine{00574\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00575\ \ \ \ \ \}\ else\ \{}
\DoxyCodeLine{00576\ \ \ \ \ \ \ \ \ //\ Compressed\ mode}
\DoxyCodeLine{00577\ \ \ \ \ \ \ \ \ for\ (size\_t\ i\ =\ 0;\ i\ <\ compressed\_data\_.outer\_ptr.size()\ -\/\ 1;\ ++i)\ \{}
\DoxyCodeLine{00578\ \ \ \ \ \ \ \ \ \ \ \ \ auto\ row\_start\ =\ compressed\_data\_.outer\_ptr[i];}
\DoxyCodeLine{00579\ \ \ \ \ \ \ \ \ \ \ \ \ auto\ row\_end\ =\ compressed\_data\_.outer\_ptr[i\ +\ 1];}
\DoxyCodeLine{00580\ }
\DoxyCodeLine{00581\ \ \ \ \ \ \ \ \ \ \ \ \ std::unordered\_map<size\_t,\ T>\ row\_values;}
\DoxyCodeLine{00582\ \ \ \ \ \ \ \ \ \ \ \ \ for\ (size\_t\ idx\ =\ row\_start;\ idx\ <\ row\_end;\ ++idx)\ \{}
\DoxyCodeLine{00583\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ row\_values[compressed\_data\_.inner\_index[idx]]\ =\ compressed\_data\_.values[idx];}
\DoxyCodeLine{00584\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00585\ }
\DoxyCodeLine{00586\ \ \ \ \ \ \ \ \ \ \ \ \ for\ (size\_t\ j\ =\ 0;\ j\ <\ cols\_;\ ++j)\ \{}
\DoxyCodeLine{00587\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (row\_values.count(j))\ \{}
\DoxyCodeLine{00588\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ std::setw(width)\ <<\ row\_values[j];}
\DoxyCodeLine{00589\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ else\ \{}
\DoxyCodeLine{00590\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ std::setw(width)\ <<\ T(0);}
\DoxyCodeLine{00591\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00592\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00593\ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ '\(\backslash\)n';}
\DoxyCodeLine{00594\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00595\ \ \ \ \ \}}
\DoxyCodeLine{00596\ \}}
\DoxyCodeLine{00597\ }
\DoxyCodeLine{00598\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00599\ void\ Matrix<T,\ Order>::printStorage()\ const\ \{}
\DoxyCodeLine{00600\ //\ Prints\ the\ storage\ format\ of\ the\ matrix\ (compressed\ or\ uncompressed).}
\DoxyCodeLine{00601\ //\ Displays\ the\ compressed\ sparse\ representation\ (CSR/CSC)\ or\ the\ uncompressed\ COO\ format,\ showing\ values,\ indices,\ and\ pointers.}
\DoxyCodeLine{00602\ //\ Outputs\ the\ matrix\ storage\ details\ to\ the\ console.}
\DoxyCodeLine{00603\ }
\DoxyCodeLine{00604\ \ \ \ \ if(is\_compressed())\{}
\DoxyCodeLine{00605\ \ \ \ \ \ \ \ \ //\ Print\ CSR/CSC\ vectors}
\DoxyCodeLine{00606\ \ \ \ \ \ \ \ \ std::cout\ <<\ std::string(50,\ '-\/')\ <<\ "{}\(\backslash\)n"{};}
\DoxyCodeLine{00607\ \ \ \ \ \ \ \ \ std::cout\ <<\ "{}\ \ \ \ \ \ \ \ \ Compressed\ Sparse\ Representation\ \(\backslash\)n"{};}
\DoxyCodeLine{00608\ \ \ \ \ \ \ \ \ std::cout\ <<\ std::string(50,\ '-\/')\ <<\ "{}\(\backslash\)n"{};}
\DoxyCodeLine{00609\ }
\DoxyCodeLine{00610\ \ \ \ \ \ \ \ \ std::cout\ <<\ "{}Values:\ \ \ \ \ \ \ \ "{};}
\DoxyCodeLine{00611\ \ \ \ \ \ \ \ \ for\ (const\ auto\&\ v\ :\ compressed\_data\_.values)\ \{}
\DoxyCodeLine{00612\ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ v\ <<\ "{}\ "{};}
\DoxyCodeLine{00613\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00614\ \ \ \ \ \ \ \ \ std::cout\ <<\ "{}\(\backslash\)n"{};}
\DoxyCodeLine{00615\ }
\DoxyCodeLine{00616\ \ \ \ \ \ \ \ \ std::cout\ <<\ "{}Inner\ index:\ \ \ "{};}
\DoxyCodeLine{00617\ \ \ \ \ \ \ \ \ for\ (const\ auto\&\ i\ :\ compressed\_data\_.inner\_index)\ \{}
\DoxyCodeLine{00618\ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ i\ <<\ "{}\ "{};}
\DoxyCodeLine{00619\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00620\ \ \ \ \ \ \ \ \ std::cout\ <<\ "{}\(\backslash\)n"{};}
\DoxyCodeLine{00621\ }
\DoxyCodeLine{00622\ \ \ \ \ \ \ \ \ std::cout\ <<\ "{}Outer\ pointer:\ "{};}
\DoxyCodeLine{00623\ \ \ \ \ \ \ \ \ for\ (const\ auto\&\ o\ :\ compressed\_data\_.outer\_ptr)\ \{}
\DoxyCodeLine{00624\ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ o\ <<\ "{}\ "{};}
\DoxyCodeLine{00625\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00626\ \ \ \ \ \ \ \ \ std::cout\ <<\ "{}\(\backslash\)n"{};}
\DoxyCodeLine{00627\ \ \ \ \ \ \ \ \ std::cout\ <<\ std::string(50,\ '-\/')\ <<\ "{}\(\backslash\)n"{};}
\DoxyCodeLine{00628\ \ \ \ \ \}}
\DoxyCodeLine{00629\ \ \ \ \ else\{}
\DoxyCodeLine{00630\ \ \ \ \ \ \ \ \ //\ Print\ COOmap\ Representation}
\DoxyCodeLine{00631\ \ \ \ \ \ \ \ \ std::cout\ <<\ std::string(50,\ '-\/')\ <<\ "{}\(\backslash\)n"{};}
\DoxyCodeLine{00632\ \ \ \ \ \ \ \ \ std::cout\ <<\ "{}\ \ \ \ Uncompressed\ Sparse\ Representation\ (Coo-\/MAP)\(\backslash\)n"{};}
\DoxyCodeLine{00633\ \ \ \ \ \ \ \ \ std::cout\ <<\ std::string(50,\ '-\/')\ <<\ "{}\(\backslash\)n"{};}
\DoxyCodeLine{00634\ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{00635\ \ \ \ \ \ \ \ \ for\ (const\ auto\&\ [key,\ val]\ :\ sparse\_data\_)\ \{}
\DoxyCodeLine{00636\ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ "{}Key:\ ("{}\ <<\ key[0]\ <<\ "{},\ "{}\ <<\ key[1]}
\DoxyCodeLine{00637\ \ \ \ \ \ \ \ \ \ \ \ \ <<\ "{})\ -\/>\ Value:\ "{}\ <<\ val\ <<\ std::endl;}
\DoxyCodeLine{00638\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00639\ }
\DoxyCodeLine{00640\ \ \ \ \ \ \ \ \ std::cout\ <<\ "{}\(\backslash\)n"{};}
\DoxyCodeLine{00641\ \ \ \ \ \ \ \ \ std::cout\ <<\ std::string(50,\ '-\/')\ <<\ "{}\(\backslash\)n"{};}
\DoxyCodeLine{00642\ \ \ \ \ \}}
\DoxyCodeLine{00643\ \}}
\DoxyCodeLine{00644\ }
\DoxyCodeLine{00645\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00646\ size\_t\ Matrix<T,\ Order>::weight()\ const\{}
\DoxyCodeLine{00647\ //\ Calculates\ the\ memory\ usage\ (weight)\ of\ the\ matrix\ based\ on\ its\ storage\ format.}
\DoxyCodeLine{00648\ //\ For\ compressed\ matrices,\ it\ sums\ the\ sizes\ of\ the\ values,\ indices,\ and\ pointers;\ for\ uncompressed,\ it\ estimates\ based\ on\ the\ sparse\ data\ structure.}
\DoxyCodeLine{00649\ //\ Outputs:\ the\ memory\ size\ in\ bytes.}
\DoxyCodeLine{00650\ }
\DoxyCodeLine{00651\ \ \ \ \ if\ (is\_compressed())\{}
\DoxyCodeLine{00652\ \ \ \ \ \ \ \ \ return\ compressed\_data\_.values.size()\ *\ sizeof(T)+\ compressed\_data\_.inner\_index.size()\ *\ sizeof(size\_t)+\ compressed\_data\_.outer\_ptr.size()\ *\ sizeof(size\_t);}
\DoxyCodeLine{00653\ }
\DoxyCodeLine{00654\ \ \ \ \ \}}
\DoxyCodeLine{00655\ \ \ \ \ else\{}
\DoxyCodeLine{00656\ \ \ \ \ \ \ \ \ size\_t\ size\_per\_element\ =\ sizeof(std::array<size\_t,\ 2>)\ +\ sizeof(T)\ +\ 3\ *\ sizeof(void*)\ +\ sizeof(bool);}
\DoxyCodeLine{00657\ \ \ \ \ \ \ \ \ return\ sizeof(sparse\_data\_)\ +\ sparse\_data\_.size()\ *\ size\_per\_element;}
\DoxyCodeLine{00658\ \ \ \ \ \}}
\DoxyCodeLine{00659\ \}}
\DoxyCodeLine{00660\ }
\DoxyCodeLine{00661\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00662\ bool\ Matrix<T,\ Order>::is\_compressed()\ const\{}
\DoxyCodeLine{00663\ //\ Checks\ whether\ the\ matrix\ is\ in\ compressed\ form\ (CSR/CSC).}
\DoxyCodeLine{00664\ //\ Returns\ true\ if\ all\ three\ components\ of\ compressed\_data\_\ are\ non-\/empty.}
\DoxyCodeLine{00665\ }
\DoxyCodeLine{00666\ \ \ \ return\ compressed\_data\_.values.size()\ !=\ 0\ \&\&\ compressed\_data\_.inner\_index.size()\ !=\ 0\ \&\&\ compressed\_data\_.outer\_ptr.size()\ !=\ 0;}
\DoxyCodeLine{00667\ \}}
\DoxyCodeLine{00668\ }
\DoxyCodeLine{00669\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00670\ void\ Matrix<T,\ Order>::info()\ const\ \{}
\DoxyCodeLine{00671\ //\ Prints\ a\ summary\ of\ the\ matrix\ information\ to\ std::cout.}
\DoxyCodeLine{00672\ }
\DoxyCodeLine{00673\ \ \ \ \ std::cout\ <<\ std::string(50,\ '*')\ <<\ std::endl;}
\DoxyCodeLine{00674\ \ \ \ \ std::cout\ <<\ "{}*\ \ \ \ \ \ \ \ \ \ \ Matrix\ Information\ Summary\ \ \ \ \ \ \ \ \ \ \ *"{}\ <<\ std::endl;}
\DoxyCodeLine{00675\ \ \ \ \ std::cout\ <<\ std::string(50,\ '*')\ <<\ std::endl;}
\DoxyCodeLine{00676\ \ \ \ \ std::cout\ <<\ std::left;}
\DoxyCodeLine{00677\ \ \ \ \ std::cout\ <<\ std::setw(30)\ <<\ "{}\ \ Size:"{}\ <<\ rows\_\ <<\ "{}\ x\ "{}\ <<\ cols\_\ <<\ std::endl;}
\DoxyCodeLine{00678\ \ \ \ \ std::cout\ <<\ std::setw(30)\ <<\ "{}\ \ Storage\ Order:"{}\ <<\ storageOrderToString(Order)\ <<\ std::endl;}
\DoxyCodeLine{00679\ \ \ \ \ std::cout\ <<\ std::setw(30)\ <<\ "{}\ \ Element\ Type:"{}\ <<\ utils::demangle(typeid(T).name())\ <<\ std::endl;}
\DoxyCodeLine{00680\ \ \ \ \ std::cout\ <<\ std::setw(30)\ <<\ "{}\ \ Compression\ status:"{}\ <<\ (is\_compressed()\ ?\ "{}Compressed"{}\ :\ "{}Uncompressed"{})\ <<\ std::endl;}
\DoxyCodeLine{00681\ \ \ \ \ std::cout\ <<\ std::setw(30)\ <<\ "{}\ \ Memory\ usage\ (bytes):"{}\ <<\ weight()\ <<\ std::endl;}
\DoxyCodeLine{00682\ \ \ \ \ std::cout\ <<\ std::string(50,\ '*')\ <<\ std::endl;}
\DoxyCodeLine{00683\ \}}
\DoxyCodeLine{00684\ }
\DoxyCodeLine{00685\ template<typename\ T,\ StorageOrder\ Order>}
\DoxyCodeLine{00686\ std::array<size\_t,\ 2>\ \ Matrix<T,Order>::size()\ const\ \{}
\DoxyCodeLine{00687\ \ \ \ \ return\ \{rows\_,\ cols\_\};}
\DoxyCodeLine{00688\ \}}
\DoxyCodeLine{00689\ }
\DoxyCodeLine{00690\ //\ ‚úùÔ∏è\ GRAVEYARD\ :\ DEPRECATED\ FUNCTIONS}
\DoxyCodeLine{00691\ //\ ashes\ have\ been\ scattered,\ nothing\ to\ see\ here}
\DoxyCodeLine{00692\ }
\DoxyCodeLine{00693\ }
\DoxyCodeLine{00694\ \}\ //\ namespace\ algebra}

\end{DoxyCode}
